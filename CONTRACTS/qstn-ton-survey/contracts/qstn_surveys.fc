

#include "imports/stdlib.fc";
#include "imports/tuple.fc";
;; operation approve created with c prefix, arbiter can approve

const op::approve = "op::approve"c; 

const op::addparticipant = "op::addparticipant"c; 

;;operation cancel created with c prefix,arbiter can cancel in case of any kind of dispute;

const op::cancel = "op::cancel"c; 

const op::notify = "op::notify"c; ;;operation notify with c prefix ,arbiter will be notified by owner;

;;operation close created with c prefix, survey is closed to new answers;
const op::close = "op::close"c; 

const int error::not_an_participant = 402;
const int error::already_exists = 409;

global int ctx_id; 
global int approved;
global int canceled;
global int closed;
global slice arbiter;     ;;ariter who approve transfer by ...
global slice beneficiary; ;;beneficiary who receives contracts fund after transfer approvment...
global cell participants; ;; dict participant_addresses
global slice owner;       ;;owner of the escrow contract initiated in deployment...  
global slice job_description; ;;small job description 

const int computation_fee = 1000000000; ;;computational gas consumption confiscated from non-arbiter
const int min_arbiter_call = 150000000; ;;min arbiter approve message sending fee 


(int, int, int, int, slice, slice, slice, slice, cell) load_data () impure inline_ref {
  slice ds = get_data().begin_parse();
  return (
    ctx_id = ds~load_uint(32), ;; ctx_id
    approved = ds~load_uint(2), ;; approved
    canceled = ds~load_uint(2), ;; canceled
    closed = ds~load_uint(2), ;; closed
    arbiter = ds~load_msg_addr(), ;; arbiter
    beneficiary = ds~load_msg_addr(), ;; beneficiary
    owner = ds~load_msg_addr(), ;; owner
    job_description = ds~load_ref().begin_parse(), ;; job_description
    participants = ds~load_dict() ;; participants
  );
}
() save_data(int newapproved,int newcanceled,int newclosed, cell participants) impure inline {
    load_data();
    set_data(begin_cell()
            .store_uint(ctx_id,32)
            .store_uint(newapproved,2)
            .store_uint(newcanceled,2)
            .store_uint(newclosed,2)
            .store_slice(arbiter)
            .store_slice(beneficiary)
            .store_slice(owner)
            .store_dict(participants)
            .store_ref( begin_cell()
                        .store_slice(job_description)
                        .end_cell())
            .end_cell()
    );
}

;; `get_participants` returns a dict of participants stored in c4 cell.
;; key: uint256 (public key), value: (key: uint32 (coin id), value: uint256 (public key for chain))
cell get_participants() inline {
    (_, _, _, _, _, _,_,_, cell participants) = load_data();
    return participants;
}

() rewardmsg(slice participant, int amount) impure {
    (_, int participant_address_hash) = parse_std_addr(participant);
    cell participants = get_participants();
    (_, int is_participant) = participants.udict_get?(256, participant_address_hash);

    throw_if(error::not_an_participant, ~ is_participant);

  load_data();
    var message = begin_cell()
        .store_uint(0x10, 6)
        .store_slice(participant)
        .store_coins(amount)
        .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
        .store_uint(0, 32)
        .store_slice("Hello, participant your reward has been confirmed!")
        .end_cell();

    send_raw_message(message, 128);

}
() transfermsg(slice beneficiary) impure {
  load_data();
    var message = begin_cell()
        .store_uint(0x10, 6)
        .store_slice(beneficiary)
        .store_coins(0)
        .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
        .store_uint(0, 32)
        .store_slice("Hello,beneficiary Your payment has been confirmed!")
        .end_cell();

    send_raw_message(message, 128);

}
() cancelmsg(slice owner) impure {
  load_data();
  var message = begin_cell()
      .store_uint(0x10,6)
      .store_slice(owner)
      .store_coins(0)
      .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
      .store_uint(0, 32)
      .store_slice("Hello,Arbiter canceled the transaction!")
      .end_cell();
     send_raw_message(message,128);
}
() closemsg(slice owner) impure {
  load_data();
  var message = begin_cell()
      .store_uint(0x10,6)
      .store_slice(owner)
      .store_coins(0)
      .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
      .store_uint(0, 32)
      .store_slice("Hello, survey is closed!")
      .end_cell();
     send_raw_message(message,128);
}

() notifymsg() impure {
  load_data();
  var message = begin_cell()
      .store_uint(0x18,6)
      .store_slice(arbiter)
      .store_coins(0)
      .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
      .store_uint(0, 32)
      .store_slice("Message's originated from escrow contract!")
      .end_cell();
     send_raw_message(message,64);
}

() nonarbitermsg(sender,sender_value) impure {
     load_data();
     var message = begin_cell()
         .store_uint(0x10,6)
         .store_slice(sender)
         .store_coins(sender_value)
         .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1) ;; 107 zero-bits
         .store_uint(0,32)
         .store_slice("Warning Non-Arbiter Address ,Computation fee will be confiscated!")
         .end_cell();
       send_raw_message(message,3);  
}

() add_participant(slice participant) {
  ;; check if participant already exists to prevent overwriting
  (_, int participant_address_hash) = parse_std_addr(participant);
  cell participants = get_participants();
  (_, int participant_exists) = participants.udict_get?(256, participant_address_hash);
  throw_if(error::already_exists, participant_exists);  

  ;; if owner is current owner, skipped the update process
  if (equal_slice_bits(owner, participant)) { return (); }

  participants~udict_set(256, participant_address_hash, participant);

  return ();
}

() recv_internal (int msg_value,cell in_msg_full,slice in_msg_body) {
     
    throw_unless(187,msg_value > min_arbiter_call); ;;throw exception if the msg value lower then 1.5 TON...

    if (in_msg_body.slice_empty?()) { ;; ignore empty messages
        return ();
    }
    slice cs = in_msg_full.begin_parse();
    int flags = cs~load_uint(4);

    if (flags & 1) { ;; ignore all bounced messages
        return ();
    }
    slice sender_address = cs~load_msg_addr();
    load_data();
     if (~ equal_slice_bits(sender_address, arbiter)) {
       int confiscated_value = msg_value - computation_fee;
        nonarbitermsg(sender_address,confiscated_value); ;; confiscate computation fee as TON from non-arbiter user
        return();
    }
    
   
    int op = in_msg_body~load_uint(32);
    int query_id = in_msg_body~load_uint(64);

   
    if (op == op::approve){
    load_data();
    transfermsg(beneficiary);
    save_data(1,0,0,participants);
      return();
    }
    if (op == op::addparticipant){
    load_data();
    add_participant(sender_address);
    save_data(1,0,0,participants);
      return();
    }
    if(op == op::cancel){
    load_data();
    cancelmsg(owner);
    save_data(0,1,0,participants);
      return();
    }
    if(op == op::close){
    load_data();
    closemsg(owner);
    save_data(0,0,1,participants);
      return();
    }

    if(op == op::notify) {
      notifymsg();
      return();
    }
    throw(0xffff);
}

(slice) get_arbiter() method_id {
load_data();
return arbiter;
}

(slice) get_beneficiary() method_id {
load_data();
return beneficiary;
}

slice get_owner() method_id {
  load_data();
  return owner;
}

int get_queryid() method_id {
  load_data();
  return ctx_id;
}

slice get_jobDescription() method_id {
  load_data();
  return job_description;
}

int get_approved() method_id {
  load_data();
  return approved;
}

int get_canceled() method_id {
   load_data();
   return canceled;
}

int get_closed() method_id {
   load_data();
   return closed;
}
